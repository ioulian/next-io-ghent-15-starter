import { mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { glob } from "node:fs/promises";
import { dirname, resolve } from "node:path";

import SVGSpriter from "svg-sprite";

import svgoConfig from "../../svgo.config.mjs";
import { ID_SEPARATOR, NODE_MODULES_SPRITES, SPRITE_FILE, SPRITE_FOLDER, SPRITE_MODULE_PATH } from "./constants";

const getSpriter = () => {
  return new SVGSpriter({
    shape: {
      id: {
        // SVG shape ID related options
        separator: ID_SEPARATOR, // Separator for directory name traversal
        pseudo: "~", // File name separator for shape states (e.g. ':hover')
      },
      dimension: {
        // Dimension related options
        maxWidth: 2000, // Max. shape width
        maxHeight: 2000, // Max. shape height
        precision: 2, // Floating point precision
        attributes: false, // Width and height attributes on embedded shapes
      },
      spacing: {
        // Spacing related options
        padding: 0, // Padding around all shapes
        box: "content", // Padding strategy (similar to CSS `box-sizing`)
      },
      transform: [
        {
          svgo: {
            // @ts-expect-error types are not fully supported
            plugins: svgoConfig.plugins,
          },
        },
      ],
    },
    mode: {
      symbol: {
        dest: SPRITE_FOLDER,
        sprite: SPRITE_FILE,
      },
    },
    svg: {
      xmlDeclaration: true, // Add XML declaration to SVG sprite
      doctypeDeclaration: true, // Add DOCTYPE declaration to SVG sprite
      namespaceIDs: true, // Add namespace token to all IDs in SVG shapes
      namespaceIDPrefix: "", // Add a prefix to the automatically generated namespaceIDs
      namespaceClassnames: true, // Add namespace token to all CSS class names in SVG shapes
      dimensionAttributes: true, // Width and height attributes on the sprite
    },
  });
};

const getCustomSprites = async (spriter: SVGSpriter.SVGSpriter) => {
  // eslint-disable-next-line baseline-js/use-baseline
  const customSprites = await Array.fromAsync(glob("src/svg-sprites/**/*.svg", { cwd: resolve(__dirname, "../..") }));

  return customSprites.map((customSprite) => {
    const name = customSprite.replace("src/svg-sprites/", "");
    spriter.add(customSprite, name, readFileSync(resolve(__dirname, "../..", customSprite), "utf-8"));

    return name.replace(".svg", "");
  });
};

const getNodeModuleSprites = async (spriter: SVGSpriter.SVGSpriter) => {
  return Object.entries(NODE_MODULES_SPRITES).map(([name, path]) => {
    spriter.add(name, name, readFileSync(require.resolve(path), "utf-8"));

    return name.replace(".svg", "");
  });
};

const writeSprite = async (spriter: SVGSpriter.SVGSpriter) => {
  const { result, data } = await spriter.compileAsync();

  const definitions: Record<string, { viewBox: string }> = {};

  // @ts-expect-error types are not fully supporte
  data.symbol.shapes.forEach((shape) => {
    const matches = shape.svg.match(/viewBox="(\d+ \d+ \d+ \d+)"/);

    if (matches.length !== 0) {
      definitions[shape.name.replaceAll(ID_SEPARATOR, "/")] = { viewBox: matches[1] };
    }
  });

  const content = `// This file is autogenerated by scripts/svg-sprite. Do not edit this file manually!

export const ID_SEPARATOR = "${ID_SEPARATOR}";
export const SPRITE_FILE = "${SPRITE_FILE}";

export type SvgSpriteName = ${Object.keys(definitions)
    .map((name) => `"${name}"`)
    .join(" | ")};

export const SVG_SPRITE_DEFINITIONS: Record<SvgSpriteName, {viewBox: string}> = {
${Object.entries(definitions)
  .map(([name, definition]) => `"${name}": { viewBox: "${definition.viewBox}" }`)
  .join(",\n")}
};
`;
  writeFileSync(`${SPRITE_MODULE_PATH}/SvgSprite.generated.ts`, content);

  for (const mode of Object.values(result)) {
    // @ts-expect-error types are not fully supported
    for (const resource of Object.values(mode)) {
      // @ts-expect-error types are not fully supported
      mkdirSync(dirname(resource.path), { recursive: true });
      // @ts-expect-error types are not fully supported
      writeFileSync(resource.path, resource.contents);
    }
  }
};

const getSprites = async () => {
  const spriter = getSpriter();

  await getCustomSprites(spriter);
  await getNodeModuleSprites(spriter);

  writeSprite(spriter);
};

getSprites();
